# Copyright 2021 DeepMind Technologies Limited
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""Constants used in AlphaFold."""

import os
import collections
import functools
import json
from typing import Mapping, List, Tuple

import numpy as np

# Internal import (35fd).
from profold2.utils import env

# molecule type
PROT = 1
DNA = 2
RNA = 3

# Distance from one CA to next CA [trans configuration: omega = 180].
ca_ca = 3.80209737096

# Format: The list for each AA type contains chi1, chi2, chi3, chi4 in
# this order (or a relevant subset from chi1 onwards). ALA and GLY don't have
# chi angles so their chi angle lists are empty.
torsion_angles_atoms = {
    'ALA': [['CA', 'C', 'N', 'CA'], ['C', 'N', 'CA', 'C'], ['N', 'CA', 'C', 'O']],
    # Chi5 in arginine is always 0 +- 5 degrees, so ignore it.
    'ARG': [['CA', 'C', 'N', 'CA'], ['C', 'N', 'CA', 'C'], ['N', 'CA', 'C', 'O'],
            ['N', 'CA', 'CB', 'CG'], ['CA', 'CB', 'CG', 'CD'], ['CB', 'CG', 'CD', 'NE'],
            ['CG', 'CD', 'NE', 'CZ']],
    'ASN': [['CA', 'C', 'N', 'CA'], ['C', 'N', 'CA', 'C'], ['N', 'CA', 'C', 'O'],
            ['N', 'CA', 'CB', 'CG'], ['CA', 'CB', 'CG', 'OD1']],
    'ASP': [['CA', 'C', 'N', 'CA'], ['C', 'N', 'CA', 'C'], ['N', 'CA', 'C', 'O'],
            ['N', 'CA', 'CB', 'CG'], ['CA', 'CB', 'CG', 'OD1']],
    'CYS': [['CA', 'C', 'N', 'CA'], ['C', 'N', 'CA', 'C'], ['N', 'CA', 'C', 'O'],
            ['N', 'CA', 'CB', 'SG']],
    'GLN': [['CA', 'C', 'N', 'CA'], ['C', 'N', 'CA', 'C'], ['N', 'CA', 'C', 'O'],
            ['N', 'CA', 'CB', 'CG'], ['CA', 'CB', 'CG', 'CD'],
            ['CB', 'CG', 'CD', 'OE1']],
    'GLU': [['CA', 'C', 'N', 'CA'], ['C', 'N', 'CA', 'C'], ['N', 'CA', 'C', 'O'],
            ['N', 'CA', 'CB', 'CG'], ['CA', 'CB', 'CG', 'CD'],
            ['CB', 'CG', 'CD', 'OE1']],
    'GLY': [['CA', 'C', 'N', 'CA'], ['C', 'N', 'CA', 'C'], ['N', 'CA', 'C', 'O']],
    'HIS': [['CA', 'C', 'N', 'CA'], ['C', 'N', 'CA', 'C'], ['N', 'CA', 'C', 'O'],
            ['N', 'CA', 'CB', 'CG'], ['CA', 'CB', 'CG', 'ND1']],
    'ILE': [['CA', 'C', 'N', 'CA'], ['C', 'N', 'CA', 'C'], ['N', 'CA', 'C', 'O'],
            ['N', 'CA', 'CB', 'CG1'], ['CA', 'CB', 'CG1', 'CD1']],
    'LEU': [['CA', 'C', 'N', 'CA'], ['C', 'N', 'CA', 'C'], ['N', 'CA', 'C', 'O'],
            ['N', 'CA', 'CB', 'CG'], ['CA', 'CB', 'CG', 'CD1']],
    'LYS': [['CA', 'C', 'N', 'CA'], ['C', 'N', 'CA', 'C'], ['N', 'CA', 'C', 'O'],
            ['N', 'CA', 'CB', 'CG'], ['CA', 'CB', 'CG', 'CD'],
            ['CB', 'CG', 'CD', 'CE'], ['CG', 'CD', 'CE', 'NZ']],
    'MET': [['CA', 'C', 'N', 'CA'], ['C', 'N', 'CA', 'C'], ['N', 'CA', 'C', 'O'],
            ['N', 'CA', 'CB', 'CG'], ['CA', 'CB', 'CG', 'SD'],
            ['CB', 'CG', 'SD', 'CE']],
    'PHE': [['CA', 'C', 'N', 'CA'], ['C', 'N', 'CA', 'C'], ['N', 'CA', 'C', 'O'],
            ['N', 'CA', 'CB', 'CG'], ['CA', 'CB', 'CG', 'CD1']],
    'PRO': [['CA', 'C', 'N', 'CA'], ['C', 'N', 'CA', 'C'], ['N', 'CA', 'C', 'O'],
            ['N', 'CA', 'CB', 'CG'], ['CA', 'CB', 'CG', 'CD']],
    'SER': [['CA', 'C', 'N', 'CA'], ['C', 'N', 'CA', 'C'], ['N', 'CA', 'C', 'O'],
            ['N', 'CA', 'CB', 'OG']],
    'THR': [['CA', 'C', 'N', 'CA'], ['C', 'N', 'CA', 'C'], ['N', 'CA', 'C', 'O'],
            ['N', 'CA', 'CB', 'OG1']],
    'TRP': [['CA', 'C', 'N', 'CA'], ['C', 'N', 'CA', 'C'], ['N', 'CA', 'C', 'O'],
            ['N', 'CA', 'CB', 'CG'], ['CA', 'CB', 'CG', 'CD1']],
    'TYR': [['CA', 'C', 'N', 'CA'], ['C', 'N', 'CA', 'C'], ['N', 'CA', 'C', 'O'],
            ['N', 'CA', 'CB', 'CG'], ['CA', 'CB', 'CG', 'CD1']],
    'VAL': [['CA', 'C', 'N', 'CA'], ['C', 'N', 'CA', 'C'], ['N', 'CA', 'C', 'O'],
            ['N', 'CA', 'CB', 'CG1']],
    ' DA': [['P', 'OP2', 'OP1', 'P'], ['OP2', 'OP1', 'P', 'OP2'], [],
            ['OP1', 'P', 'O5\'', 'C5\''], ['P', 'O5\'', 'C5\'', 'C4\''],
            ['O5\'', 'C5\'', 'C4\'', 'C3\''], ['C5\'', 'C4\'', 'C3\'', 'O3\''],
            ['C5\'', 'C4\'', 'O4\'', 'C1\''], ['C4\'', 'O4\'', 'C1\'', 'C2\''],
            ['O4\'', 'C1\'', 'N9', 'C2']],
    ' DC': [['P', 'OP2', 'OP1', 'P'], ['OP2', 'OP1', 'P', 'OP2'], [],
            ['OP1', 'P', 'O5\'', 'C5\''], ['P', 'O5\'', 'C5\'', 'C4\''],
            ['O5\'', 'C5\'', 'C4\'', 'C3\''], ['C5\'', 'C4\'', 'C3\'', 'O3\''],
            ['C5\'', 'C4\'', 'O4\'', 'C1\''], ['C4\'', 'O4\'', 'C1\'', 'C2\''],
            ['O4\'', 'C1\'', 'N1', 'C2']],
    ' DG': [['P', 'OP2', 'OP1', 'P'], ['OP2', 'OP1', 'P', 'OP2'], [],
            ['OP1', 'P', 'O5\'', 'C5\''], ['P', 'O5\'', 'C5\'', 'C4\''],
            ['O5\'', 'C5\'', 'C4\'', 'C3\''], ['C5\'', 'C4\'', 'C3\'', 'O3\''],
            ['C5\'', 'C4\'', 'O4\'', 'C1\''], ['C4\'', 'O4\'', 'C1\'', 'C2\''],
            ['O4\'', 'C1\'', 'N9', 'C2']],
    ' DT': [['P', 'OP2', 'OP1', 'P'], ['OP2', 'OP1', 'P', 'OP2'], [],
            ['OP1', 'P', 'O5\'', 'C5\''], ['P', 'O5\'', 'C5\'', 'C4\''],
            ['O5\'', 'C5\'', 'C4\'', 'C3\''], ['C5\'', 'C4\'', 'C3\'', 'O3\''],
            ['C5\'', 'C4\'', 'O4\'', 'C1\''], ['C4\'', 'O4\'', 'C1\'', 'C2\''],
            ['O4\'', 'C1\'', 'N1', 'C2']],
    ' DX': [['P', 'OP2', 'OP1', 'P'], ['OP2', 'OP1', 'P', 'OP2'], [],
            ['OP1', 'P', 'O5\'', 'C5\''], ['P', 'O5\'', 'C5\'', 'C4\''],
            ['O5\'', 'C5\'', 'C4\'', 'C3\''], ['C5\'', 'C4\'', 'C3\'', 'O3\''],
            ['C5\'', 'C4\'', 'O4\'', 'C1\''], ['C4\'', 'O4\'', 'C1\'', 'C2\''],
            []],
    '  A': [['P', 'OP2', 'OP1', 'P'], ['OP2', 'OP1', 'P', 'OP2'], [],
            ['OP1', 'P', 'O5\'', 'C5\''], ['P', 'O5\'', 'C5\'', 'C4\''],
            ['O5\'', 'C5\'', 'C4\'', 'C3\''], ['C5\'', 'C4\'', 'C3\'', 'O3\''],
            ['C5\'', 'C4\'', 'O4\'', 'C1\''], ['C4\'', 'O4\'', 'C1\'', 'C2\''],
            ['O4\'', 'C1\'', 'N9', 'C2'], ['O4\'', 'C1\'', 'C2\'', 'C3\'']],
    '  C': [['P', 'OP2', 'OP1', 'P'], ['OP2', 'OP1', 'P', 'OP2'], [],
            ['OP1', 'P', 'O5\'', 'C5\''], ['P', 'O5\'', 'C5\'', 'C4\''],
            ['O5\'', 'C5\'', 'C4\'', 'C3\''], ['C5\'', 'C4\'', 'C3\'', 'O3\''],
            ['C5\'', 'C4\'', 'O4\'', 'C1\''], ['C4\'', 'O4\'', 'C1\'', 'C2\''],
            ['O4\'', 'C1\'', 'N1', 'C2'], ['O4\'', 'C1\'', 'C2\'', 'C3\'']],
    '  G': [['P', 'OP2', 'OP1', 'P'], ['OP2', 'OP1', 'P', 'OP2'], [],
            ['OP1', 'P', 'O5\'', 'C5\''], ['P', 'O5\'', 'C5\'', 'C4\''],
            ['O5\'', 'C5\'', 'C4\'', 'C3\''], ['C5\'', 'C4\'', 'C3\'', 'O3\''],
            ['C5\'', 'C4\'', 'O4\'', 'C1\''], ['C4\'', 'O4\'', 'C1\'', 'C2\''],
            ['O4\'', 'C1\'', 'N9', 'C2'], ['O4\'', 'C1\'', 'C2\'', 'C3\'']],
    '  U': [['P', 'OP2', 'OP1', 'P'], ['OP2', 'OP1', 'P', 'OP2'], [],
            ['OP1', 'P', 'O5\'', 'C5\''], ['P', 'O5\'', 'C5\'', 'C4\''],
            ['O5\'', 'C5\'', 'C4\'', 'C3\''], ['C5\'', 'C4\'', 'C3\'', 'O3\''],
            ['C5\'', 'C4\'', 'O4\'', 'C1\''], ['C4\'', 'O4\'', 'C1\'', 'C2\''],
            ['O4\'', 'C1\'', 'N1', 'C2'], ['O4\'', 'C1\'', 'C2\'', 'C3\'']],
    '  X': [['P', 'OP2', 'OP1', 'P'], ['OP2', 'OP1', 'P', 'OP2'], [],
            ['OP1', 'P', 'O5\'', 'C5\''], ['P', 'O5\'', 'C5\'', 'C4\''],
            ['O5\'', 'C5\'', 'C4\'', 'C3\''], ['C5\'', 'C4\'', 'C3\'', 'O3\''],
            ['C5\'', 'C4\'', 'O4\'', 'C1\''], ['C4\'', 'O4\'', 'C1\'', 'C2\''],
            [],['O4\'', 'C1\'', 'C2\'', 'C3\'']],
}

# If chi angles given in fixed-length array, this matrix determines how to mask
# them for each AA type. The order is as per restype_order (see below).
torsion_angles_mask = [
    [1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # ALA
    [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0],  # ARG
    [1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # ASN
    [1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # ASP
    [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # CYS
    [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # GLN
    [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # GLU
    [1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # GLY
    [1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # HIS
    [1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # ILE
    [1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # LEU
    [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0],  # LYS
    [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # MET
    [1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # PHE
    [1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # PRO
    [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # SER
    [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # THR
    [1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # TRP
    [1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # TYR
    [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # VAL
    [1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0],  #  DA
    [1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0],  #  DC
    [1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0],  #  DG
    [1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0],  #  DT
    [1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0],  #  DX
    [1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0],  #   A
    [1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0],  #   C
    [1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0],  #   G
    [1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0],  #   U
    [1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0],  #   X
    [1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # UNK
]

# chi angles dependencies:
#
# bb (0)
# |------ \omega (1)
# |------ \phi (2)
# |------ \psi (3)
# |------ \chi_1 (4)
# |         |------ \chi_2 (5)
# |                   |------- \chi_3 (6)
# |                              |-------- \chi_4 (7)
# |------ \alpha (4)
#           |------ \beta (5)
#                     |------- \gamma (6)
#                                |-------- \eta (7)
#                                |-------- \nu_2 (8)
#                                            |-------- \nu_1 (9)
#                                                        |-------- \chi (10)
#                                                        |-------- \nu_0 (11)
#

torsion_angles_depend = [
    [0, 0, 0, 0, 4, 5, 6, 0, 0, 0, 0],  # ALA
    [0, 0, 0, 0, 4, 5, 6, 0, 0, 0, 0],  # ARG
    [0, 0, 0, 0, 4, 5, 6, 0, 0, 0, 0],  # ASN
    [0, 0, 0, 0, 4, 5, 6, 0, 0, 0, 0],  # ASP
    [0, 0, 0, 0, 4, 5, 6, 0, 0, 0, 0],  # CYS
    [0, 0, 0, 0, 4, 5, 6, 0, 0, 0, 0],  # GLN
    [0, 0, 0, 0, 4, 5, 6, 0, 0, 0, 0],  # GLU
    [0, 0, 0, 0, 4, 5, 6, 0, 0, 0, 0],  # GLY
    [0, 0, 0, 0, 4, 5, 6, 0, 0, 0, 0],  # HIS
    [0, 0, 0, 0, 4, 5, 6, 0, 0, 0, 0],  # ILE
    [0, 0, 0, 0, 4, 5, 6, 0, 0, 0, 0],  # LEU
    [0, 0, 0, 0, 4, 5, 6, 0, 0, 0, 0],  # LYS
    [0, 0, 0, 0, 4, 5, 6, 0, 0, 0, 0],  # MET
    [0, 0, 0, 0, 4, 5, 6, 0, 0, 0, 0],  # PHE
    [0, 0, 0, 0, 4, 5, 6, 0, 0, 0, 0],  # PRO
    [0, 0, 0, 0, 4, 5, 6, 0, 0, 0, 0],  # SER
    [0, 0, 0, 0, 4, 5, 6, 0, 0, 0, 0],  # THR
    [0, 0, 0, 0, 4, 5, 6, 0, 0, 0, 0],  # TRP
    [0, 0, 0, 0, 4, 5, 6, 0, 0, 0, 0],  # TYR
    [0, 0, 0, 0, 4, 5, 6, 0, 0, 0, 0],  # VAL
    [0, 0, 0, 0, 4, 5, 6, 6, 8, 9, 0],  #  DA
    [0, 0, 0, 0, 4, 5, 6, 6, 8, 9, 0],  #  DC
    [0, 0, 0, 0, 4, 5, 6, 6, 8, 9, 0],  #  DG
    [0, 0, 0, 0, 4, 5, 6, 6, 8, 9, 0],  #  DT
    [0, 0, 0, 0, 4, 5, 6, 6, 8, 0, 0],  #  DX
    [0, 0, 0, 0, 4, 5, 6, 6, 8, 9, 9],  #   A
    [0, 0, 0, 0, 4, 5, 6, 6, 8, 9, 9],  #   C
    [0, 0, 0, 0, 4, 5, 6, 6, 8, 9, 9],  #   G
    [0, 0, 0, 0, 4, 5, 6, 6, 8, 9, 9],  #   U
    [0, 0, 0, 0, 4, 5, 6, 6, 8, 0, 9],  #   X
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],  # UNK
]

# The following chi angles are pi periodic: they can be rotated by a multiple
# of pi without affecting the structure.
chi_pi_periodic = [
    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # ALA
    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # ARG
    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # ASN
    [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # ASP
    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # CYS
    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # GLN
    [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # GLU
    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # GLY
    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # HIS
    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # ILE
    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # LEU
    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # LYS
    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # MET
    [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # PHE
    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # PRO
    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # SER
    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # THR
    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # TRP
    [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # TYR
    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # VAL
    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  #  DA
    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  #  DC
    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  #  DG
    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  #  DT
    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  #  DX
    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  #   A
    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  #   C
    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  #   G
    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  #   U
    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  #   X
    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # UNK
]

# Atoms positions relative to the 8 rigid groups, defined by the pre-omega, phi,
# psi and chi angles:
# 0: 'backbone group',
# 1: 'pre-omega-group', (empty)
# 2: 'phi-group', (currently empty, because it defines only hydrogens)
# 3: 'psi-group',
# 4,5,6,7: 'chi1,2,3,4-group'
# The atom positions are relative to the axis-end-atom of the corresponding
# rotation axis. The x-axis is in direction of the rotation axis, and the y-axis
# is defined such that the dihedral-angle-definiting atom (the last entry in
# chi_angles_atoms above) is in the xy-plane (with a positive y-coordinate).
# format: [atomname, group_idx, rel_position]
rigid_group_atom_positions = {
    'ALA': [
        ['N', 0, (-0.525, 1.363, 0.000)],
        ['CA', 0, (0.000, 0.000, 0.000)],
        ['C', 0, (1.526, -0.000, -0.000)],
        ['CB', 0, (-0.529, -0.774, -1.205)],
        ['O', 3, (0.627, 1.062, 0.000)],
    ],
    'ARG': [
        ['N', 0, (-0.524, 1.362, -0.000)],
        ['CA', 0, (0.000, 0.000, 0.000)],
        ['C', 0, (1.525, -0.000, -0.000)],
        ['CB', 0, (-0.524, -0.778, -1.209)],
        ['O', 3, (0.626, 1.062, 0.000)],
        ['CG', 4, (0.616, 1.390, -0.000)],
        ['CD', 5, (0.564, 1.414, 0.000)],
        ['NE', 6, (0.539, 1.357, -0.000)],
        ['NH1', 7, (0.206, 2.301, 0.000)],
        ['NH2', 7, (2.078, 0.978, -0.000)],
        ['CZ', 7, (0.758, 1.093, -0.000)],
    ],
    'ASN': [
        ['N', 0, (-0.536, 1.357, 0.000)],
        ['CA', 0, (0.000, 0.000, 0.000)],
        ['C', 0, (1.526, -0.000, -0.000)],
        ['CB', 0, (-0.531, -0.787, -1.200)],
        ['O', 3, (0.625, 1.062, 0.000)],
        ['CG', 4, (0.584, 1.399, 0.000)],
        ['ND2', 5, (0.593, -1.188, 0.001)],
        ['OD1', 5, (0.633, 1.059, 0.000)],
    ],
    'ASP': [
        ['N', 0, (-0.525, 1.362, -0.000)],
        ['CA', 0, (0.000, 0.000, 0.000)],
        ['C', 0, (1.527, 0.000, -0.000)],
        ['CB', 0, (-0.526, -0.778, -1.208)],
        ['O', 3, (0.626, 1.062, -0.000)],
        ['CG', 4, (0.593, 1.398, -0.000)],
        ['OD1', 5, (0.610, 1.091, 0.000)],
        ['OD2', 5, (0.592, -1.101, -0.003)],
    ],
    'CYS': [
        ['N', 0, (-0.522, 1.362, -0.000)],
        ['CA', 0, (0.000, 0.000, 0.000)],
        ['C', 0, (1.524, 0.000, 0.000)],
        ['CB', 0, (-0.519, -0.773, -1.212)],
        ['O', 3, (0.625, 1.062, -0.000)],
        ['SG', 4, (0.728, 1.653, 0.000)],
    ],
    'GLN': [
        ['N', 0, (-0.526, 1.361, -0.000)],
        ['CA', 0, (0.000, 0.000, 0.000)],
        ['C', 0, (1.526, 0.000, 0.000)],
        ['CB', 0, (-0.525, -0.779, -1.207)],
        ['O', 3, (0.626, 1.062, -0.000)],
        ['CG', 4, (0.615, 1.393, 0.000)],
        ['CD', 5, (0.587, 1.399, -0.000)],
        ['NE2', 6, (0.593, -1.189, -0.001)],
        ['OE1', 6, (0.634, 1.060, 0.000)],
    ],
    'GLU': [
        ['N', 0, (-0.528, 1.361, 0.000)],
        ['CA', 0, (0.000, 0.000, 0.000)],
        ['C', 0, (1.526, -0.000, -0.000)],
        ['CB', 0, (-0.526, -0.781, -1.207)],
        ['O', 3, (0.626, 1.062, 0.000)],
        ['CG', 4, (0.615, 1.392, 0.000)],
        ['CD', 5, (0.600, 1.397, 0.000)],
        ['OE1', 6, (0.607, 1.095, -0.000)],
        ['OE2', 6, (0.589, -1.104, -0.001)],
    ],
    'GLY': [
        ['N', 0, (-0.572, 1.337, 0.000)],
        ['CA', 0, (0.000, 0.000, 0.000)],
        ['C', 0, (1.517, -0.000, -0.000)],
        ['O', 3, (0.626, 1.062, -0.000)],
    ],
    'HIS': [
        ['N', 0, (-0.527, 1.360, 0.000)],
        ['CA', 0, (0.000, 0.000, 0.000)],
        ['C', 0, (1.525, 0.000, 0.000)],
        ['CB', 0, (-0.525, -0.778, -1.208)],
        ['O', 3, (0.625, 1.063, 0.000)],
        ['CG', 4, (0.600, 1.370, -0.000)],
        ['CD2', 5, (0.889, -1.021, 0.003)],
        ['ND1', 5, (0.744, 1.160, -0.000)],
        ['CE1', 5, (2.030, 0.851, 0.002)],
        ['NE2', 5, (2.145, -0.466, 0.004)],
    ],
    'ILE': [
        ['N', 0, (-0.493, 1.373, -0.000)],
        ['CA', 0, (0.000, 0.000, 0.000)],
        ['C', 0, (1.527, -0.000, -0.000)],
        ['CB', 0, (-0.536, -0.793, -1.213)],
        ['O', 3, (0.627, 1.062, -0.000)],
        ['CG1', 4, (0.534, 1.437, -0.000)],
        ['CG2', 4, (0.540, -0.785, -1.199)],
        ['CD1', 5, (0.619, 1.391, 0.000)],
    ],
    'LEU': [
        ['N', 0, (-0.520, 1.363, 0.000)],
        ['CA', 0, (0.000, 0.000, 0.000)],
        ['C', 0, (1.525, -0.000, -0.000)],
        ['CB', 0, (-0.522, -0.773, -1.214)],
        ['O', 3, (0.625, 1.063, -0.000)],
        ['CG', 4, (0.678, 1.371, 0.000)],
        ['CD1', 5, (0.530, 1.430, -0.000)],
        ['CD2', 5, (0.535, -0.774, 1.200)],
    ],
    'LYS': [
        ['N', 0, (-0.526, 1.362, -0.000)],
        ['CA', 0, (0.000, 0.000, 0.000)],
        ['C', 0, (1.526, 0.000, 0.000)],
        ['CB', 0, (-0.524, -0.778, -1.208)],
        ['O', 3, (0.626, 1.062, -0.000)],
        ['CG', 4, (0.619, 1.390, 0.000)],
        ['CD', 5, (0.559, 1.417, 0.000)],
        ['CE', 6, (0.560, 1.416, 0.000)],
        ['NZ', 7, (0.554, 1.387, 0.000)],
    ],
    'MET': [
        ['N', 0, (-0.521, 1.364, -0.000)],
        ['CA', 0, (0.000, 0.000, 0.000)],
        ['C', 0, (1.525, 0.000, 0.000)],
        ['CB', 0, (-0.523, -0.776, -1.210)],
        ['O', 3, (0.625, 1.062, -0.000)],
        ['CG', 4, (0.613, 1.391, -0.000)],
        ['SD', 5, (0.703, 1.695, 0.000)],
        ['CE', 6, (0.320, 1.786, -0.000)],
    ],
    'PHE': [
        ['N', 0, (-0.518, 1.363, 0.000)],
        ['CA', 0, (0.000, 0.000, 0.000)],
        ['C', 0, (1.524, 0.000, -0.000)],
        ['CB', 0, (-0.525, -0.776, -1.212)],
        ['O', 3, (0.626, 1.062, -0.000)],
        ['CG', 4, (0.607, 1.377, 0.000)],
        ['CD1', 5, (0.709, 1.195, -0.000)],
        ['CD2', 5, (0.706, -1.196, 0.000)],
        ['CE1', 5, (2.102, 1.198, -0.000)],
        ['CE2', 5, (2.098, -1.201, -0.000)],
        ['CZ', 5, (2.794, -0.003, -0.001)],
    ],
    'PRO': [
        ['N', 0, (-0.566, 1.351, -0.000)],
        ['CA', 0, (0.000, 0.000, 0.000)],
        ['C', 0, (1.527, -0.000, 0.000)],
        ['CB', 0, (-0.546, -0.611, -1.293)],
        ['O', 3, (0.621, 1.066, 0.000)],
        ['CG', 4, (0.382, 1.445, 0.0)],
        # ['CD', 5, (0.427, 1.440, 0.0)],
        ['CD', 5, (0.477, 1.424, 0.0)],  # manually made angle 2 degrees larger
    ],
    'SER': [
        ['N', 0, (-0.529, 1.360, -0.000)],
        ['CA', 0, (0.000, 0.000, 0.000)],
        ['C', 0, (1.525, -0.000, -0.000)],
        ['CB', 0, (-0.518, -0.777, -1.211)],
        ['O', 3, (0.626, 1.062, -0.000)],
        ['OG', 4, (0.503, 1.325, 0.000)],
    ],
    'THR': [
        ['N', 0, (-0.517, 1.364, 0.000)],
        ['CA', 0, (0.000, 0.000, 0.000)],
        ['C', 0, (1.526, 0.000, -0.000)],
        ['CB', 0, (-0.516, -0.793, -1.215)],
        ['O', 3, (0.626, 1.062, 0.000)],
        ['CG2', 4, (0.550, -0.718, -1.228)],
        ['OG1', 4, (0.472, 1.353, 0.000)],
    ],
    'TRP': [
        ['N', 0, (-0.521, 1.363, 0.000)],
        ['CA', 0, (0.000, 0.000, 0.000)],
        ['C', 0, (1.525, -0.000, 0.000)],
        ['CB', 0, (-0.523, -0.776, -1.212)],
        ['O', 3, (0.627, 1.062, 0.000)],
        ['CG', 4, (0.609, 1.370, -0.000)],
        ['CD1', 5, (0.824, 1.091, 0.000)],
        ['CD2', 5, (0.854, -1.148, -0.005)],
        ['CE2', 5, (2.186, -0.678, -0.007)],
        ['CE3', 5, (0.622, -2.530, -0.007)],
        ['NE1', 5, (2.140, 0.690, -0.004)],
        ['CH2', 5, (3.028, -2.890, -0.013)],
        ['CZ2', 5, (3.283, -1.543, -0.011)],
        ['CZ3', 5, (1.715, -3.389, -0.011)],
    ],
    'TYR': [
        ['N', 0, (-0.522, 1.362, 0.000)],
        ['CA', 0, (0.000, 0.000, 0.000)],
        ['C', 0, (1.524, -0.000, -0.000)],
        ['CB', 0, (-0.522, -0.776, -1.213)],
        ['O', 3, (0.627, 1.062, -0.000)],
        ['CG', 4, (0.607, 1.382, -0.000)],
        ['CD1', 5, (0.716, 1.195, -0.000)],
        ['CD2', 5, (0.713, -1.194, -0.001)],
        ['CE1', 5, (2.107, 1.200, -0.002)],
        ['CE2', 5, (2.104, -1.201, -0.003)],
        ['OH', 5, (4.168, -0.002, -0.005)],
        ['CZ', 5, (2.791, -0.001, -0.003)],
    ],
    'VAL': [
        ['N', 0, (-0.494, 1.373, -0.000)],
        ['CA', 0, (0.000, 0.000, 0.000)],
        ['C', 0, (1.527, -0.000, -0.000)],
        ['CB', 0, (-0.533, -0.795, -1.213)],
        ['O', 3, (0.627, 1.062, -0.000)],
        ['CG1', 4, (0.540, 1.429, -0.000)],
        ['CG2', 4, (0.533, -0.776, 1.203)],
    ],
    ' DA': [
        ['OP1', 0, (-0.7319, 1.2920, 0.000)],
        ['P', 0, (0.000, 0.000, 0.000)],
        ['OP2', 0, (1.4855, 0.000, 0.000)],
        ['O5\'', 0, (-0.4948, -0.8559,  1.2489)],
        ['C5\'', 4, (0.7411, -1.2354, 0.000)],
        ['C4\'', 5, (0.5207,  1.4178, 0.000)],
        ['O4\'', 6, (0.4804, -0.6610, -1.1947)],
        ['C3\'', 6, (0.6388, 1.3889, 0.000)],
        ['O3\'', 7, (0.4966, 1.3432, 0.000)],
        ['C1\'', 8, (0.4913, 1.3316, 0.0000)],
        ['C2\'', 9, (0.4167, 1.4603, 0.0000)],
        ['N9', 9, (0.4467, -0.7474, -1.1746)],
        ['N1', 10, (2.7960, 2.8816, 0.0000)],
        ['C4', 10, (0.8119, 1.1084, 0.0000)],
        ['N3', 10, (0.4328, 2.3976, 0.0000)],
        ['C2', 10, (1.4957, 3.1983, 0.0000)],
        ['C6', 10, (3.1433, 1.5760, 0.0000)],
        ['C5', 10, (2.1084, 0.6255, 0.0000)],
        ['N7', 10, (2.1145, -0.7627, 0.0000)],
        ['C8', 10, (0.8438, -1.0825, 0.0000)],
        ['N6', 10, (4.4402, 1.2598, 0.0000)],
    ],
    ' DC': [
        ['OP1', 0, (-0.7319, 1.2920, 0.000)],
        ['P', 0, (0.000, 0.000, 0.000)],
        ['OP2', 0, (1.4855, 0.000, 0.000)],
        ['O5\'', 0, (-0.4948, -0.8559,  1.2489)],
        ['C5\'', 4, (0.7411, -1.2354, 0.000)],
        ['C4\'', 5, (0.5207,  1.4178, 0.000)],
        ['O4\'', 6, (0.4804, -0.6610, -1.1947)],
        ['C3\'', 6, (0.6388, 1.3889, 0.000)],
        ['O3\'', 7, (0.4966, 1.3432, 0.000)],
        ['C1\'', 8, (0.4913, 1.3316, 0.0000)],
        ['C2\'', 9, (0.4167, 1.4603, 0.0000)],
        ['N1', 9, (0.4467, -0.7474, -1.1746)],
        ['C2', 10, (0.6758, 1.2249, 0.0000)],
        ['O2', 10, (0.0158, 2.2756, 0.0000)],
        ['N3', 10, (2.0283, 1.2334, 0.0000)],
        ['C4', 10, (2.7022, 0.0815, 0.0000)],
        ['N4', 10, (4.0356, 0.1372, 0.0000)],
        ['C5', 10, (2.0394, -1.1794, 0.0000)],
        ['C6', 10, (0.7007, -1.1745, 0.0000)],
    ],
    ' DG': [
        ['OP1', 0, (-0.7319, 1.2920, 0.000)],
        ['P', 0, (0.000, 0.000, 0.000)],
        ['OP2', 0, (1.4855, 0.000, 0.000)],
        ['O5\'', 0, (-0.4948, -0.8559, 1.2489)],
        ['C5\'', 4, (0.7411, -1.2354, 0.000)],
        ['C4\'', 5, (0.5207,  1.4178, 0.000)],
        ['O4\'', 6, (0.4804, -0.6610, -1.1947)],
        ['C3\'', 6, (0.6388, 1.3889, 0.000)],
        ['O3\'', 7, (0.4966, 1.3432, 0.000)],
        ['C1\'', 8, (0.4913, 1.3316, 0.0000)],
        ['C2\'', 9, (0.4167, 1.4603, 0.0000)],
        ['N9', 9, (0.4467, -0.7474, -1.1746)],
        ['N1', 10, (2.7493, 2.8397, 0.0000)],
        ['C4', 10, (0.8171, 1.1043, 0.0000)],
        ['N3', 10, (0.4110, 2.3918, 0.0000)],
        ['C2', 10, (1.4330, 3.2319, 0.0000)],
        ['C6', 10, (3.1894, 1.5195, 0.0000)],
        ['C5', 10, (2.1029, 0.6070, 0.0000)],
        ['N7', 10, (2.0942, -0.7800, 0.0000)],
        ['C8', 10, (0.8285, -1.0956, 0.0000)],
        ['N2', 10, (1.2085, 4.5537, 0.0000)],
        ['O6', 10, (4.4017, 1.2743, 0.0000)],
    ],
    ' DT': [
        ['OP1', 0, (-0.7319, 1.2920, 0.000)],
        ['P', 0, (0.000, 0.000, 0.000)],
        ['OP2', 0, (1.4855, 0.000, 0.000)],
        ['O5\'', 0, (-0.4948, -0.8559,  1.2489)],
        ['C5\'', 4, (0.7411, -1.2354, 0.000)],
        ['C4\'', 5, (0.5207,  1.4178, 0.000)],
        ['O4\'', 6, (0.4804, -0.6610, -1.1947)],
        ['C3\'', 6, (0.6388, 1.3889, 0.000)],
        ['O3\'', 7, (0.4966, 1.3432, 0.000)],
        ['C1\'', 8, (0.4913, 1.3316, 0.0000)],
        ['C2\'', 9, (0.4167, 1.4603, 0.0000)],
        ['N1', 9, (0.4467, -0.7474, -1.1746)],
        ['C2', 10, (0.6495, 1.2140, 0.0000)],
        ['O2', 10, (0.0636, 2.2854, 0.0000)],
        ['N3', 10, (2.0191, 1.1297, 0.0000)],
        ['C4', 10, (2.7859, -0.0198, 0.0000)],
        ['O4', 10, (4.0113, 0.0622, 0.0000)],
        ['C5', 10, (2.0397, -1.2580, 0.0000)],
        ['C7', 10, (2.7845, -2.5550, 0.0000)],
        ['C6', 10, (0.7021, -1.1863, 0.0000)],
    ],
    ' DX': [
        ['OP1', 0, (-0.7319, 1.2920, 0.000)],
        ['P', 0, (0.000, 0.000, 0.000)],
        ['OP2', 0, (1.4855, 0.000, 0.000)],
        ['O5\'', 0, (-0.4948, -0.8559, 1.2489)],
        ['C5\'', 4, (0.7411, -1.2354, 0.000)],
        ['C4\'', 5, (0.5207, 1.4178, 0.000)],
        ['O4\'', 6, (0.4804, -0.6610, -1.1947)],
        ['C3\'', 6, (0.6388, 1.3889, 0.000)],
        ['O3\'', 7, (0.4966, 1.3432, 0.000)],
        ['C1\'', 8, (0.4913, 1.3316, 0.0000)],
        ['C2\'', 9, (0.4167, 1.4603, 0.0000)],
    ],
    '  A': [
        ['OP1', 0, (-0.7319, 1.2920, 0.000)],
        ['P', 0, (0.000, 0.000, 0.000)],
        ['OP2', 0, (1.4855, 0.000, 0.000)],
        ['O5\'', 0, (-0.4948, -0.8559, 1.2489)],
        ['C5\'', 4, (0.7289, 1.2185, 0.000)],
        ['C4\'', 5, (0.5541,  1.4027, 0.000)],
        ['O4\'', 6, (0.4914, -0.6338, -1.2098)],
        ['C3\'', 6, (0.6673, 1.3669, 0.000)],
        ['O3\'', 7, (0.5548, 1.3039, 0.000)],
        ['C1\'', 8, (0.4828, 1.3277, 0.0000)],
        ['C2\'', 9, (0.4641, 1.4573, 0.0000)],
        ['O2\'', 11, (0.4613, -0.6189, 1.1921)],
        ['N9', 9, (0.4722, -0.7339, -1.1894)],
        ['N1', 10, (2.7963, 2.8824, 0.0000)],
        ['C2', 10, (1.4955, 3.2007, 0.0000)],
        ['N3', 10, (0.4333, 2.3980, 0.0000)],
        ['C4', 10, (0.8127, 1.1078, 0.0000)],
        ['C5', 10, (2.1082, 0.6254, 0.0000)],
        ['C6', 10, (3.1432, 1.5774, 0.0000)],
        ['N6', 10, (4.4400, 1.2609, 0.0000)],
        ['N7', 10, (2.1146, -0.7630, 0.0000)],
        ['C8', 10, (0.8442, -1.0830, 0.0000)],
    ],
    '  C': [
        ['OP1', 0, (-0.7319, 1.2920, 0.000)],
        ['P', 0, (0.000, 0.000, 0.000)],
        ['OP2', 0, (1.4855, 0.000, 0.000)],
        ['O5\'', 0, (-0.4948, -0.8559, 1.2489)],
        ['C5\'', 4, (0.7289, 1.2185, 0.000)],
        ['C4\'', 5, (0.5541,  1.4027, 0.000)],
        ['O4\'', 6, (0.4914, -0.6338, -1.2098)],
        ['C3\'', 6, (0.6673, 1.3669, 0.000)],
        ['O3\'', 7, (0.5548, 1.3039, 0.000)],
        ['C1\'', 8, (0.4828, 1.3277, 0.0000)],
        ['C2\'', 9, (0.4641, 1.4573, 0.0000)],
        ['O2\'', 11, (0.4613, -0.6189, 1.1921)],
        ['N1', 9, (0.4722, -0.7339, -1.1894)],
        ['C2', 10, (0.6650, 1.2325, 0.0000)],
        ['O2', 10, (-0.0001, 2.2799, 0.0000)],
        ['N3', 10, (2.0175, 1.2603, 0.0000)],
        ['C4', 10, (2.7090, 0.1210, 0.0000)],
        ['N4', 10, (4.0423, 0.1969, 0.0000)],
        ['C5', 10, (2.0635, -1.1476, 0.0000)],
        ['C6', 10, (0.7250, -1.1627, 0.0000)],
    ],
    '  G': [
        ['OP1', 0, (-0.7319, 1.2920, 0.000)],
        ['P', 0, (0.000, 0.000, 0.000)],
        ['OP2', 0, (1.4855, 0.000, 0.000)],
        ['O5\'', 0, (-0.4948, -0.8559, 1.2489)],
        ['C5\'', 4, (0.7289, 1.2185, 0.000)],
        ['C4\'', 5, (0.5541,  1.4027, 0.000)],
        ['O4\'', 6, (0.4914, -0.6338, -1.2098)],
        ['C3\'', 6, (0.6673, 1.3669, 0.000)],
        ['O3\'', 7, (0.5548, 1.3039, 0.000)],
        ['C1\'', 8, (0.4828, 1.3277, -0.0000)],
        ['C2\'', 9, (0.4641, 1.4573, 0.0000)],
        ['O2\'', 11, (0.4613, -0.6189, 1.1921)],
        ['N9', 9, (0.4722, -0.7339, -1.1894)],
        ['N1', 10, (2.7458, 2.8461, 0.0000)],
        ['C2', 10, (1.4286, 3.2360, 0.0000)],
        ['N2', 10, (1.1989, 4.5575, 0.0000)],
        ['N3', 10, (0.4087, 2.3932, 0.0000)],
        ['C4', 10, (0.8167, 1.1068, 0.0000)],
        ['C5', 10, (2.1036, 0.6115, 0.0000)],
        ['C6', 10, (3.1883, 1.5266, 0.0000)],
        ['O6', 10, (4.4006, 1.2842, 0.0000)],
        ['N7', 10, (2.0980, -0.7759, 0.0000)],
        ['C8', 10, (0.8317, -1.0936, 0.0000)],
    ],
    '  U': [
        ['OP1', 0, (-0.7319, 1.2920, 0.000)],
        ['P', 0, (0.000, 0.000, 0.000)],
        ['OP2', 0, (1.4855, 0.000, 0.000)],
        ['O5\'', 0, (-0.4948, -0.8559, 1.2489)],
        ['C5\'', 4, (0.7289, 1.2185, 0.000)],
        ['C4\'', 5, (0.5541,  1.4027, 0.000)],
        ['O4\'', 6, (0.4914, -0.6338, -1.2098)],
        ['C3\'', 6, (0.6673, 1.3669, 0.000)],
        ['O3\'', 7, (0.5548, 1.3039, 0.000)],
        ['C1\'', 8, (0.4828, 1.3277, 0.0000)],
        ['C2\'', 9, (0.4641, 1.4573, 0.0000)],
        ['O2\'', 11, (0.4613, -0.6189, 1.1921)],
        ['N1', 9, (0.4722, -0.7339, -1.1894)],
        ['C2', 10, (0.6307, 1.2305, 0.0000)],
        ['O2', 10, (0.0260, 2.2886, 0.0000)],
        ['N3', 10, (2.0031, 1.1816, 0.0000)],
        ['C4', 10, (2.7953, 0.0532, 0.0000)],
        ['O4', 10, (4.0212, 0.1751, 0.0000)],
        ['C5', 10, (2.0746, -1.1833, 0.0000)],
        ['C6', 10, (0.7378, -1.1648, 0.0000)],
    ],
    '  X': [
        ['OP1', 0, (-0.7319, 1.2920, 0.000)],
        ['P', 0, (0.000, 0.000, 0.000)],
        ['OP2', 0, (1.4855, 0.000, 0.000)],
        ['O5\'', 0, (-0.4948, -0.8559, 1.2489)],
        ['C5\'', 4, (0.7289, 1.2185, 0.000)],
        ['C4\'', 5, (0.5541,  1.4027, 0.000)],
        ['O4\'', 6, (0.4914, -0.6338, -1.2098)],
        ['C3\'', 6, (0.6673, 1.3669, 0.000)],
        ['O3\'', 7, (0.5548, 1.3039, 0.000)],
        ['C1\'', 8, (0.4828, 1.3277, 0.0000)],
        ['C2\'', 9, (0.4641, 1.4573, 0.0000)],
        ['O2\'', 11, (0.4613, -0.6189, 1.1921)],
    ],
}

# A list of atoms (excluding hydrogen) for each AA type. PDB naming convention.
residue_atoms = {
    'ALA': ['C', 'CA', 'CB', 'N', 'O'],
    'ARG': ['C', 'CA', 'CB', 'CG', 'CD', 'CZ', 'N', 'NE', 'O', 'NH1', 'NH2'],
    'ASP': ['C', 'CA', 'CB', 'CG', 'N', 'O', 'OD1', 'OD2'],
    'ASN': ['C', 'CA', 'CB', 'CG', 'N', 'ND2', 'O', 'OD1'],
    'CYS': ['C', 'CA', 'CB', 'N', 'O', 'SG'],
    'GLU': ['C', 'CA', 'CB', 'CG', 'CD', 'N', 'O', 'OE1', 'OE2'],
    'GLN': ['C', 'CA', 'CB', 'CG', 'CD', 'N', 'NE2', 'O', 'OE1'],
    'GLY': ['C', 'CA', 'N', 'O'],
    'HIS': ['C', 'CA', 'CB', 'CG', 'CD2', 'CE1', 'N', 'ND1', 'NE2', 'O'],
    'ILE': ['C', 'CA', 'CB', 'CG1', 'CG2', 'CD1', 'N', 'O'],
    'LEU': ['C', 'CA', 'CB', 'CG', 'CD1', 'CD2', 'N', 'O'],
    'LYS': ['C', 'CA', 'CB', 'CG', 'CD', 'CE', 'N', 'NZ', 'O'],
    'MET': ['C', 'CA', 'CB', 'CG', 'CE', 'N', 'O', 'SD'],
    'PHE': ['C', 'CA', 'CB', 'CG', 'CD1', 'CD2', 'CE1', 'CE2', 'CZ', 'N', 'O'],
    'PRO': ['C', 'CA', 'CB', 'CG', 'CD', 'N', 'O'],
    'SER': ['C', 'CA', 'CB', 'N', 'O', 'OG'],
    'THR': ['C', 'CA', 'CB', 'CG2', 'N', 'O', 'OG1'],
    'TRP': ['C', 'CA', 'CB', 'CG', 'CD1', 'CD2', 'CE2', 'CE3', 'CZ2', 'CZ3',
            'CH2', 'N', 'NE1', 'O'],
    'TYR': ['C', 'CA', 'CB', 'CG', 'CD1', 'CD2', 'CE1', 'CE2', 'CZ', 'N', 'O',
            'OH'],
    'VAL': ['C', 'CA', 'CB', 'CG1', 'CG2', 'N', 'O']
}

# Naming swaps for ambiguous atom names.
# Due to symmetries in the amino acids the naming of atoms is ambiguous in
# 4 of the 20 amino acids.
# (The LDDT paper lists 7 amino acids as ambiguous, but the naming ambiguities
# in LEU, VAL and ARG can be resolved by using the 3d constellations of
# the 'ambiguous' atoms and their neighbours)
residue_atom_renaming_swaps = {
    'ASP': {'OD1': 'OD2'},
    'GLU': {'OE1': 'OE2'},
    'PHE': {'CD1': 'CD2', 'CE1': 'CE2'},
    'TYR': {'CD1': 'CD2', 'CE1': 'CE2'},
}

# Van der Waals radii [Angstroem] of the atoms (from Wikipedia)
van_der_waals_radius = {
    'C': 1.7,
    'N': 1.55,
    'O': 1.52,
    'S': 1.8,
}

Bond = collections.namedtuple('Bond', ['atom1_name', 'atom2_name', 'length', 'stddev'])
BondAngle = collections.namedtuple(
    'BondAngle', ['atom1_name', 'atom2_name', 'atom3name', 'angle_rad', 'stddev']
)


@functools.lru_cache(maxsize=None)
def load_stereo_chemical_props() -> Tuple[Mapping[str, List[Bond]], Mapping[
    str, List[Bond]], Mapping[str, List[BondAngle]]]:
  """Load stereo_chemical_props.txt into a nice structure.

  Load literature values for bond lengths and bond angles and translate
  bond angles into the length of the opposite edge of the triangle
  ("residue_virtual_bonds").

  Returns:
    residue_bonds:  dict that maps resname --> list of Bond tuples
    residue_virtual_bonds: dict that maps resname --> list of Bond tuples
    residue_bond_angles: dict that maps resname --> list of BondAngle tuples
  """
  stereo_chemical_props_path = os.path.join(
      os.path.dirname(__file__), 'stereo_chemical_props.txt'
  )
  with open(stereo_chemical_props_path, 'rt') as f:
    stereo_chemical_props = f.read()
  lines_iter = iter(stereo_chemical_props.splitlines())
  # Load bond lengths.
  residue_bonds = {}
  next(lines_iter)  # Skip header line.
  for line in lines_iter:
    if line.strip() == '-':
      break
    bond, resname, length, stddev = line.split()
    atom1, atom2 = bond.split('-')
    if resname not in residue_bonds:
      residue_bonds[resname] = []
    residue_bonds[resname].append(Bond(atom1, atom2, float(length), float(stddev)))
  residue_bonds['UNK'] = []

  # Load bond angles.
  residue_bond_angles = {}
  next(lines_iter)  # Skip empty line.
  next(lines_iter)  # Skip header line.
  for line in lines_iter:
    if line.strip() == '-':
      break
    bond, resname, angle_degree, stddev_degree = line.split()
    atom1, atom2, atom3 = bond.split('-')
    if resname not in residue_bond_angles:
      residue_bond_angles[resname] = []
    residue_bond_angles[resname].append(
        BondAngle(
            atom1, atom2, atom3,
            float(angle_degree) / 180. * np.pi,
            float(stddev_degree) / 180. * np.pi
        )
    )
  residue_bond_angles['UNK'] = []

  def make_bond_key(atom1_name, atom2_name):
    """Unique key to lookup bonds."""
    return '-'.join(sorted([atom1_name, atom2_name]))

  # Translate bond angles into distances ("virtual bonds").
  residue_virtual_bonds = {}
  for resname, bond_angles in residue_bond_angles.items():
    # Create a fast lookup dict for bond lengths.
    bond_cache = {}
    for b in residue_bonds[resname]:
      bond_cache[make_bond_key(b.atom1_name, b.atom2_name)] = b
    residue_virtual_bonds[resname] = []
    for ba in bond_angles:
      bond1 = bond_cache[make_bond_key(ba.atom1_name, ba.atom2_name)]
      bond2 = bond_cache[make_bond_key(ba.atom2_name, ba.atom3name)]

      # Compute distance between atom1 and atom3 using the law of cosines
      # c^2 = a^2 + b^2 - 2ab*cos(gamma).
      gamma = ba.angle_rad
      length = np.sqrt(
          bond1.length**2 + bond2.length**2 -
          2 * bond1.length * bond2.length * np.cos(gamma)
      )

      # Propagation of uncertainty assuming uncorrelated errors.
      dl_outer = 0.5 / length
      dl_dgamma = (2 * bond1.length * bond2.length * np.sin(gamma)) * dl_outer
      dl_db1 = (2 * bond1.length - 2 * bond2.length * np.cos(gamma)) * dl_outer
      dl_db2 = (2 * bond2.length - 2 * bond1.length * np.cos(gamma)) * dl_outer
      stddev = np.sqrt(
          (dl_dgamma * ba.stddev)**2 + (dl_db1 * bond1.stddev)**2 +
          (dl_db2 * bond2.stddev)**2
      )
      residue_virtual_bonds[resname].append(
          Bond(ba.atom1_name, ba.atom3name, length, stddev)
      )

  return (residue_bonds, residue_virtual_bonds, residue_bond_angles)


# Between-residue bond lengths for general bonds (first element) and for Proline
# (second element).
between_res_bond_length_c_n = [1.329, 1.341]
between_res_bond_length_stddev_c_n = [0.014, 0.016]

# Between-residue cos_angles.
between_res_cos_angles_c_n_ca = [-0.5203, 0.0353]  # degrees: 121.352 +- 2.315
between_res_cos_angles_ca_c_n = [-0.4473, 0.0311]  # degrees: 116.568 +- 1.995

# This mapping is used when we need to store atom data in a format that requires
# fixed atom data size for every residue (e.g. a numpy array).
atom_types = [
    'N', 'CA', 'C', 'O', 'CB', 'CG', 'CG1', 'CG2', 'OG', 'OG1', 'SG', 'CD',
    'CD1', 'CD2', 'ND1', 'ND2', 'OD1', 'OD2', 'SD', 'CE', 'CE1', 'CE2', 'CE3',
    'NE', 'NE1', 'NE2', 'OE1', 'OE2', 'CH2', 'NH1', 'NH2', 'OH', 'CZ', 'CZ2',
    'CZ3', 'NZ', 'OXT'
]
atom_order = {atom_type: i for i, atom_type in enumerate(atom_types)}
atom_type_num = len(atom_types)  # := 37.
atom14_type_num = env('profold2_atom14_type_num', defval=14, dtype=int)  # := 14.

# A compact atom encoding with 14 columns
# pylint: disable=line-too-long
# pylint: disable=bad-whitespace
restype_name_to_atom14_names = {
    'ALA': ['N', 'CA', 'C', 'O', 'CB', '',    '',    '',    '',    '',    '',    '',    '',    ''],
    'ARG': ['N', 'CA', 'C', 'O', 'CB', 'CG',  'CD',  'NE',  'CZ',  'NH1', 'NH2', '',    '',    ''],
    'ASN': ['N', 'CA', 'C', 'O', 'CB', 'CG',  'OD1', 'ND2', '',    '',    '',    '',    '',    ''],
    'ASP': ['N', 'CA', 'C', 'O', 'CB', 'CG',  'OD1', 'OD2', '',    '',    '',    '',    '',    ''],
    'CYS': ['N', 'CA', 'C', 'O', 'CB', 'SG',  '',    '',    '',    '',    '',    '',    '',    ''],
    'GLN': ['N', 'CA', 'C', 'O', 'CB', 'CG',  'CD',  'OE1', 'NE2', '',    '',    '',    '',    ''],
    'GLU': ['N', 'CA', 'C', 'O', 'CB', 'CG',  'CD',  'OE1', 'OE2', '',    '',    '',    '',    ''],
    'GLY': ['N', 'CA', 'C', 'O', '',   '',    '',    '',    '',    '',    '',    '',    '',    ''],
    'HIS': ['N', 'CA', 'C', 'O', 'CB', 'CG',  'ND1', 'CD2', 'CE1', 'NE2', '',    '',    '',    ''],
    'ILE': ['N', 'CA', 'C', 'O', 'CB', 'CG1', 'CG2', 'CD1', '',    '',    '',    '',    '',    ''],
    'LEU': ['N', 'CA', 'C', 'O', 'CB', 'CG',  'CD1', 'CD2', '',    '',    '',    '',    '',    ''],
    'LYS': ['N', 'CA', 'C', 'O', 'CB', 'CG',  'CD',  'CE',  'NZ',  '',    '',    '',    '',    ''],
    'MET': ['N', 'CA', 'C', 'O', 'CB', 'CG',  'SD',  'CE',  '',    '',    '',    '',    '',    ''],
    'PHE': ['N', 'CA', 'C', 'O', 'CB', 'CG',  'CD1', 'CD2', 'CE1', 'CE2', 'CZ',  '',    '',    ''],
    'PRO': ['N', 'CA', 'C', 'O', 'CB', 'CG',  'CD',  '',    '',    '',    '',    '',    '',    ''],
    'SER': ['N', 'CA', 'C', 'O', 'CB', 'OG',  '',    '',    '',    '',    '',    '',    '',    ''],
    'THR': ['N', 'CA', 'C', 'O', 'CB', 'OG1', 'CG2', '',    '',    '',    '',    '',    '',    ''],
    'TRP': ['N', 'CA', 'C', 'O', 'CB', 'CG',  'CD1', 'CD2', 'NE1', 'CE2', 'CE3', 'CZ2', 'CZ3', 'CH2'],
    'TYR': ['N', 'CA', 'C', 'O', 'CB', 'CG',  'CD1', 'CD2', 'CE1', 'CE2', 'CZ',  'OH',  '',    ''],
    'VAL': ['N', 'CA', 'C', 'O', 'CB', 'CG1', 'CG2', '',    '',    '',    '',    '',    '',    ''],
    ' DA': ['OP1', 'P', 'OP2', 'O5\'', 'C5\'','C4\'','O4\'','C3\'','O3\'','C2\'','C1\'','N1',  'C2', 'N3', 'C4', 'C5', 'C6', 'N6', 'N7', 'C8', 'N9', '',   ''],
    ' DC': ['OP1', 'P', 'OP2', 'O5\'', 'C5\'','C4\'','O4\'','C3\'','O3\'','C2\'','C1\'','N1',  'C2', 'O2', 'N3', 'C4', 'C5', 'C6', 'N4', '',   '',   '',   ''],
    ' DG': ['OP1', 'P', 'OP2', 'O5\'', 'C5\'','C4\'','O4\'','C3\'','O3\'','C2\'','C1\'','N1',  'C2', 'N2', 'N3', 'C4', 'C5', 'C6', 'O6', 'N7', 'C8', 'N9', ''],
    ' DT': ['OP1', 'P', 'OP2', 'O5\'', 'C5\'','C4\'','O4\'','C3\'','O3\'','C2\'','C1\'','N1',  'C2', 'O2', 'N3', 'C4', 'O4', 'C5', 'C6', 'C7', '',   '',   ''],
    ' DX': ['OP1', 'P', 'OP2', 'O5\'', 'C5\'','C4\'','O4\'','C3\'','O3\'','C2\'','C1\'','N1',  'C2', '',   '',   '',   '',   '',   '',   '',   '',   '',   ''],
    '  A': ['OP1', 'P', 'OP2', 'O5\'', 'C5\'','C4\'','O4\'','C3\'','O3\'','C2\'','O2\'','C1\'','N1', 'C2', 'N3', 'C4', 'C5', 'C6', 'N6', 'N7', 'C8', 'N9', ''],
    '  C': ['OP1', 'P', 'OP2', 'O5\'', 'C5\'','C4\'','O4\'','C3\'','O3\'','C2\'','O2\'','C1\'','N1', 'C2', 'O2', 'N3', 'C4', 'C5', 'C6', 'N4', '',   '',   ''],
    '  G': ['OP1', 'P', 'OP2', 'O5\'', 'C5\'','C4\'','O4\'','C3\'','O3\'','C2\'','O2\'','C1\'','N1', 'C2', 'N2', 'N3', 'C4', 'C5', 'C6', 'O6', 'N7', 'C8', 'N9'],
    '  U': ['OP1', 'P', 'OP2', 'O5\'', 'C5\'','C4\'','O4\'','C3\'','O3\'','C2\'','O2\'','C1\'','N1', 'C2', 'O2', 'N3', 'C4', 'O4', 'C5', 'C6', '',   '',   ''],
    '  X': ['OP1', 'P', 'OP2', 'O5\'', 'C5\'','C4\'','O4\'','C3\'','O3\'','C2\'','O2\'','C1\'','N1', 'C2', '',   '',   '',   '',   '',   '',   '',   '',   ''],
    'UNK': ['N', 'CA', 'C', 'O',  '',   '',    '',   '',    '',    '',    '',    '',    '',    ''],
}
# pylint: enable=line-too-long
# pylint: enable=bad-whitespace

restype_list = set(env('profold2_restype_list', defval=[PROT], dtype=json.loads))
assert restype_list

# This is the standard residue order when coding AA type as a number.
# Reproduce it by taking 3-letter AA codes and sorting them alphabetically.
restypes = ()
if PROT in restype_list:
  restypes = restypes + (
    'A', 'R', 'N', 'D', 'C', 'Q', 'E', 'G', 'H', 'I', 'L', 'K', 'M', 'F', 'P',
    'S', 'T', 'W', 'Y', 'V'
  )
if DNA in restype_list:
  restypes = restypes + ('A', 'C', 'G', 'T', 'X')
if RNA in restype_list:
  restypes = restypes + ('A', 'C', 'G', 'U', 'X')

restype_from_idx = -1
if PROT in restype_list:
  prot_from_idx, prot_to_idx = restype_from_idx + 1, restype_from_idx + 20
  restype_from_idx = prot_to_idx
else:
  prot_from_idx, prot_to_idx = -1, -1

if DNA in restype_list:
  dna_from_idx, dna_to_idx = restype_from_idx + 1, restype_from_idx + 5  # with X
  restype_from_idx = dna_to_idx
else:
  dna_from_idx, dna_to_idx = -1, -1

if RNA in restype_list:
  rna_from_idx, rna_to_idx = restype_from_idx + 1, restype_from_idx + 5  # with X
  restype_from_idx = rna_to_idx
else:
  rna_from_idx, rna_to_idx = -1, -1

if PROT in restype_list:
  restype_from_idx += 1  # with X

if PROT in restype_list:
  prot_gap_idx = restype_from_idx + 1
  restype_from_idx = prot_gap_idx
else:
  prot_gap_idx = -1

if DNA in restype_list:
  dna_gap_idx = restype_from_idx + 1
  restype_from_idx = dna_gap_idx
else:
  dna_gap_idx = -1

if RNA in restype_list:
  rna_gap_idx = restype_from_idx + 1
  restype_from_idx = rna_gap_idx
else:
  rna_gap_idx = -1
del restype_from_idx

def moltype(mol_idx):
  if dna_from_idx <= mol_idx <= dna_to_idx or mol_idx == dna_gap_idx:    # dna gap .
    return DNA
  elif rna_from_idx <= mol_idx <= rna_to_idx or mol_idx == rna_gap_idx:  # rna gap *
    return RNA
  return PROT


restype_order = {(restype, moltype(i)): i for i, restype in enumerate(restypes)}
restype_num = len(restypes)  # := 20.
unk_restype_index = restype_num  # Catch-all index for unknown restypes.


def is_aa(restype):
  return moltype(restype) == PROT


restypes_with_x = restypes + ('X', ) if PROT in restype_list else restypes
restype_order_with_x = {
    (restype, moltype(i)): i
    for i, restype in enumerate(restypes_with_x)
}


bptypes = (
    'cWW', 'tWW', 'cWH', 'tWH', 'cWS', 'tWS', 'cHH', 'tHH', 'cHS', 'tHS', 'cSS', 'tSS'
)
bptype_order = {bptype: i for i, bptype in enumerate(bptypes)}


def sequence_to_onehot(
    sequence: str,
    mapping: Mapping[str, int],
    mol_type: int = PROT,
    map_unknown_to_x: bool = False
) -> np.ndarray:
  """Maps the given sequence into a one-hot encoded matrix.

  Args:
    sequence: An amino acid sequence.
    mapping: A dictionary mapping amino acids to integers.
    map_unknown_to_x: If True, any amino acid that is not in the mapping will be
      mapped to the unknown amino acid 'X'. If the mapping doesn't contain
      amino acid 'X', an error will be thrown. If False, any amino acid not in
      the mapping will throw an error.

  Returns:
    A numpy array of shape (seq_len, num_unique_aas) with one-hot encoding of
    the sequence.

  Raises:
    ValueError: If the mapping doesn't contain values from 0 to
      num_unique_aas - 1 without any gaps.
  """
  num_entries = max(mapping.values()) + 1

  if sorted(set(mapping.values())) != list(range(num_entries)):
    raise ValueError(
        'The mapping must have values from 0 to num_unique_aas-1 '
        'without any gaps. Got: %s' % sorted(mapping.values())
    )

  one_hot_arr = np.zeros((len(sequence), num_entries), dtype=np.int32)

  for aa_index, aa_type in enumerate(sequence):
    if map_unknown_to_x:
      if aa_type.isalpha() and aa_type.isupper():
        aa_id = mapping.get((aa_type, mol_type), mapping[('X', mol_type)])
      else:
        raise ValueError(f'Invalid character in the sequence: {aa_type}')
    else:
      aa_id = mapping[(aa_type, mol_type)]
    one_hot_arr[aa_index, aa_id] = 1

  return one_hot_arr


restype_1to3 = {
    ('A', PROT): 'ALA',
    ('R', PROT): 'ARG',
    ('N', PROT): 'ASN',
    ('D', PROT): 'ASP',
    ('C', PROT): 'CYS',
    ('Q', PROT): 'GLN',
    ('E', PROT): 'GLU',
    ('G', PROT): 'GLY',
    ('H', PROT): 'HIS',
    ('I', PROT): 'ILE',
    ('L', PROT): 'LEU',
    ('K', PROT): 'LYS',
    ('M', PROT): 'MET',
    ('F', PROT): 'PHE',
    ('P', PROT): 'PRO',
    ('S', PROT): 'SER',
    ('T', PROT): 'THR',
    ('W', PROT): 'TRP',
    ('Y', PROT): 'TYR',
    ('V', PROT): 'VAL',
    ('A', DNA ): ' DA',
    ('C', DNA ): ' DC',
    ('G', DNA ): ' DG',
    ('T', DNA ): ' DT',
    ('X', DNA ): ' DX',
    ('A', RNA ): '  A',
    ('C', RNA ): '  C',
    ('G', RNA ): '  G',
    ('U', RNA ): '  U',
    ('X', RNA ): '  X',
}

# NB: restype_3to1 differs from Bio.PDB.protein_letters_3to1 by being a simple
# 1-to-1 mapping of 3 letter names to one letter names. The latter contains
# many more, and less common, three letter names as keys and maps many of these
# to the same one letter name (including 'X' and 'U' which we don't use here).
restype_3to1 = {v: k for k, v in restype_1to3.items()}

# Define a restype name for all unknown residues.
unk_restype = 'UNK'
unk_dnatype = ' DX'
unk_rnatype = '  X'

resnames = [restype_1to3[(r, moltype(i))]
            for i, r in enumerate(restypes)] + [(unk_restype, PROT)]
resname_to_idx = {resname: i for i, resname in enumerate(resnames)}

# The mapping here uses hhblits convention, so that B is mapped to D, J and O
# are mapped to X, U is mapped to C, and Z is mapped to E. Other than that the
# remaining 20 amino acids are kept in alphabetical order.
# There are 2 non-amino acid codes, X (representing any amino acid) and
# "-" representing a missing amino acid in an alignment.  The id for these
# codes is put at the end (20 and 21) so that they can easily be ignored if
# desired.
HHBLITS_AA_TO_ID = {}
if PROT in restype_list:
  HHBLITS_AA_TO_ID.update({
    ('A', PROT): prot_from_idx + 0,
    ('B', PROT): prot_from_idx + 2,
    ('C', PROT): prot_from_idx + 1,
    ('D', PROT): prot_from_idx + 2,
    ('E', PROT): prot_from_idx + 3,
    ('F', PROT): prot_from_idx + 4,
    ('G', PROT): prot_from_idx + 5,
    ('H', PROT): prot_from_idx + 6,
    ('I', PROT): prot_from_idx + 7,
    ('J', PROT): unk_restype_index,
    ('K', PROT): prot_from_idx + 8,
    ('L', PROT): prot_from_idx + 9,
    ('M', PROT): prot_from_idx + 10,
    ('N', PROT): prot_from_idx + 11,
    ('O', PROT): unk_restype_index,
    ('P', PROT): prot_from_idx + 12,
    ('Q', PROT): prot_from_idx + 13,
    ('R', PROT): prot_from_idx + 14,
    ('S', PROT): prot_from_idx + 15,
    ('T', PROT): prot_from_idx + 16,
    ('U', PROT): prot_from_idx + 1,
    ('V', PROT): prot_from_idx + 17,
    ('W', PROT): prot_from_idx + 18,
    ('X', PROT): unk_restype_index,
    ('Y', PROT): prot_from_idx + 19,
    ('Z', PROT): prot_from_idx + 3,
    ('-', PROT): prot_gap_idx,
  })
if DNA in restype_list:
  HHBLITS_AA_TO_ID.update({
    ('A', DNA ): dna_from_idx + 0,
    ('C', DNA ): dna_from_idx + 1,
    ('G', DNA ): dna_from_idx + 2,
    ('T', DNA ): dna_from_idx + 3,
    ('U', DNA ): dna_from_idx + 3,
    ('X', DNA ): dna_from_idx + 4,
    ('B', DNA ): dna_from_idx + 4,
    ('D', DNA ): dna_from_idx + 4,
    ('H', DNA ): dna_from_idx + 4,
    ('K', DNA ): dna_from_idx + 4,
    ('M', DNA ): dna_from_idx + 4,
    ('N', DNA ): dna_from_idx + 4,
    ('R', DNA ): dna_from_idx + 4,
    ('S', DNA ): dna_from_idx + 4,
    ('V', DNA ): dna_from_idx + 4,
    ('W', DNA ): dna_from_idx + 4,
    ('Y', DNA ): dna_from_idx + 4,
    ('-', DNA ): dna_gap_idx,
  })
if RNA in restype_list:
  HHBLITS_AA_TO_ID.update({
    ('A', RNA ): rna_from_idx + 0,
    ('C', RNA ): rna_from_idx + 1,
    ('G', RNA ): rna_from_idx + 2,
    ('U', RNA ): rna_from_idx + 3,
    ('T', RNA ): rna_from_idx + 3,
    ('X', RNA ): rna_from_idx + 4,
    ('B', RNA ): rna_from_idx + 4,
    ('D', RNA ): rna_from_idx + 4,
    ('H', RNA ): rna_from_idx + 4,
    ('K', RNA ): rna_from_idx + 4,
    ('M', RNA ): rna_from_idx + 4,
    ('N', RNA ): rna_from_idx + 4,
    ('R', RNA ): rna_from_idx + 4,
    ('S', RNA ): rna_from_idx + 4,
    ('V', RNA ): rna_from_idx + 4,
    ('W', RNA ): rna_from_idx + 4,
    ('Y', RNA ): rna_from_idx + 4,
    ('-', RNA ): rna_gap_idx,
  })

# Partial inversion of HHBLITS_AA_TO_ID.
ID_TO_HHBLITS_AA = {}
if PROT in restype_list:
  ID_TO_HHBLITS_AA.update({
    prot_from_idx +  0: ('A', PROT),
    prot_from_idx +  1: ('C', PROT),  # Also U.
    prot_from_idx +  2: ('D', PROT),  # Also B.
    prot_from_idx +  3: ('E', PROT),  # Also Z.
    prot_from_idx +  4: ('F', PROT),
    prot_from_idx +  5: ('G', PROT),
    prot_from_idx +  6: ('H', PROT),
    prot_from_idx +  7: ('I', PROT),
    prot_from_idx +  8: ('K', PROT),
    prot_from_idx +  9: ('L', PROT),
    prot_from_idx + 10: ('M', PROT),
    prot_from_idx + 11: ('N', PROT),
    prot_from_idx + 12: ('P', PROT),
    prot_from_idx + 13: ('Q', PROT),
    prot_from_idx + 14: ('R', PROT),
    prot_from_idx + 15: ('S', PROT),
    prot_from_idx + 16: ('T', PROT),
    prot_from_idx + 17: ('V', PROT),
    prot_from_idx + 18: ('W', PROT),
    prot_from_idx + 19: ('Y', PROT),
    unk_restype_index:  ('X', PROT),  # Includes J and O.
    prot_gap_idx:       ('-', PROT),
  })
if DNA in restype_list:
  ID_TO_HHBLITS_AA.update({
    dna_from_idx + 0: ('A', DNA),
    dna_from_idx + 1: ('C', DNA),  # Also U.
    dna_from_idx + 2: ('G', DNA),  # Also B.
    dna_from_idx + 3: ('T', DNA),  # Also T.
    dna_from_idx + 4: ('X', DNA),
    dna_gap_idx:      ('.', DNA),
  })
if RNA in restype_list:
  ID_TO_HHBLITS_AA.update({
    rna_from_idx + 0: ('A', RNA),
    rna_from_idx + 1: ('C', RNA),  # Also U.
    rna_from_idx + 2: ('G', RNA),  # Also B.
    rna_from_idx + 3: ('U', RNA),  # Also T.
    rna_from_idx + 4: ('X', RNA),
    rna_gap_idx:      ('*', RNA),
  })

restypes_gap = ()
if PROT in restype_list:
  restypes_gap = restypes_gap + ('-', )
if DNA in restype_list:
  restypes_gap = restypes_gap + ('.', )
if RNA in restype_list:
  restypes_gap = restypes_gap + ('*', )
restypes_with_x_and_gap = restypes_with_x + restypes_gap
restype_order_with_x_and_gap = {
    (restype, moltype(i)): i
    for i, restype in enumerate(restypes_with_x_and_gap)
}
MAP_HHBLITS_AATYPE_TO_OUR_AATYPE = tuple(
    restype_order_with_x_and_gap[ID_TO_HHBLITS_AA[i]]
    for i in range(len(restypes_with_x_and_gap))
)


def _make_standard_atom_mask() -> np.ndarray:
  """Returns [num_res_types, num_atom_types] mask array."""
  # +1 to account for unknown (all 0s).
  mask = np.zeros([restype_num + 1, atom14_type_num], dtype=np.int32)
  for restype, restype_letter in enumerate(restypes):
    restype_name = restype_1to3[(restype_letter, moltype(restype))]
    atom_list = restype_name_to_atom14_names[restype_name]  # pylint: disable=redefined-outer-name
    for atom_type, atom_name in enumerate(atom_list[:atom14_type_num]):  # pylint: disable=redefined-outer-name
      if atom_name:
        mask[restype, atom_type] = 1
  return mask


STANDARD_ATOM_MASK = _make_standard_atom_mask()


chi_angles_num = env('profold2_chi_angles_num', defval=7, dtype=int)
chi_angles_atom14_indices = np.zeros(
    (restype_num + 1, chi_angles_num, 4), dtype=np.int32
)
chi_angles_atom14_exists = np.zeros((restype_num + 1, chi_angles_num), dtype=np.bool_)
for res_name, res_chi_angles in torsion_angles_atoms.items():
  if res_name not in resname_to_idx:
    continue
  res_type = resname_to_idx[res_name]
  atom_list = restype_name_to_atom14_names[res_name]

  # base = 0
  #
  # omega/phi/psi(prot) = 1-3
  # chi_1-4(prot) = 4-7
  #
  # alpha/beta/gamma/delta(na) = 4-7
  # nu2/nu1/chi/nu0(na) = 8-11
  #

  # torsion angles
  for chi_idx, chi_angle in enumerate(res_chi_angles[:chi_angles_num]):
    for i, atom_name in enumerate(chi_angle):
      atom_idx = atom_list.index(atom_name)
      chi_angles_atom14_indices[res_type, chi_idx, i] = atom_idx
    chi_angles_atom14_exists[res_type, chi_idx] = 1


def _make_rigid_transformation_4x4(ex, ey, translation):
  """Create a rigid 4x4 transformation matrix from two axes and transl."""
  # Normalize ex.
  ex_normalized = ex / np.linalg.norm(ex)

  # make ey perpendicular to ex
  ey_normalized = ey - np.dot(ey, ex_normalized) * ex_normalized
  ey_normalized /= np.linalg.norm(ey_normalized)

  # compute ez as cross product
  eznorm = np.cross(ex_normalized, ey_normalized)
  m = np.stack([ex_normalized, ey_normalized, eznorm, translation]).transpose()
  m = np.concatenate([m, [[0., 0., 0., 1.]]], axis=0)
  return m


# create an array with (restype, atomtype) --> rigid_group_idx
# and an array with (restype, atomtype, coord) for the atom positions
# and compute affine transformation matrices (4,4) from one rigid group to the
# previous group
restype_atom37_to_rigid_group = np.zeros([restype_num + 1, 37], dtype=np.int32)
restype_atom37_mask = np.zeros([restype_num + 1, 37], dtype=np.bool_)
restype_atom37_rigid_group_positions = np.zeros(
    [restype_num + 1, 37, 3], dtype=np.float32
)
restype_atom14_to_rigid_group = np.zeros(
    [restype_num + 1, atom14_type_num], dtype=np.int32
)
restype_atom14_mask = np.zeros([restype_num + 1, atom14_type_num], dtype=np.bool_)
restype_atom14_rigid_group_positions = np.zeros(
    [restype_num + 1, atom14_type_num, 3], dtype=np.float32
)
restype_rigid_group_num = chi_angles_num + 1
restype_rigid_group_default_frame = np.zeros(
    [restype_num + 1, restype_rigid_group_num, 4, 4], dtype=np.float32
)
restype_rigid_group_atom37_idx = np.zeros(
    [restype_num + 1, restype_rigid_group_num, 3], dtype=np.int32
)
restype_rigid_group_atom14_idx = np.zeros(
    [restype_num + 1, restype_rigid_group_num, 3], dtype=np.int32
)
restype_rigid_group_mask = np.zeros(
    [restype_num + 1, restype_rigid_group_num], dtype=np.bool_
)
restype_rigid_group_depend = np.zeros(
    [restype_num + 1, restype_rigid_group_num], dtype=np.int64
)


def _make_rigid_group_constants():
  # def to_atom37_index(atom_names):
  #   return [atom_order[atom_name] for atom_name in atom_names]
  def to_atom14_index(resname, atom_names):
    atom_list = restype_name_to_atom14_names[resname]  # pylint: disable=redefined-outer-name
    return [atom_list.index(atom_name) for atom_name in atom_names]

  # Fill the arrays above.
  for restype, restype_letter in enumerate(restypes):
    resname = restype_1to3[(restype_letter, moltype(restype))]
    for atomname, group_idx, atom_position in rigid_group_atom_positions[resname]:
      if group_idx > chi_angles_num:
        continue
      atomtype = atom_order.get(atomname)
      if atomname is not None:
        restype_atom37_to_rigid_group[restype, atomtype] = group_idx
        restype_atom37_mask[restype, atomtype] = 1
        restype_atom37_rigid_group_positions[restype, atomtype, :] = atom_position

      atom14idx = restype_name_to_atom14_names[resname].index(atomname)
      restype_atom14_to_rigid_group[restype, atom14idx] = group_idx
      restype_atom14_mask[restype, atom14idx] = 1
      restype_atom14_rigid_group_positions[restype, atom14idx, :] = atom_position

  for restype, restype_letter in enumerate(restypes):
    resname = restype_1to3[(restype_letter, moltype(restype))]
    atom_positions = {
        name: np.array(pos)
        for name, _, pos in rigid_group_atom_positions[resname]
    }

    # backbone to backbone is the identity transform
    restype_rigid_group_default_frame[restype, 0, :, :] = np.eye(4)
    if moltype(restype) == PROT:
      restype_rigid_group_atom14_idx[restype, 0, :] = np.array(
          to_atom14_index(resname, ['C', 'CA', 'N'])
      )
    else:
      restype_rigid_group_atom14_idx[restype, 0, :] = np.array(
          to_atom14_index(resname, ['OP2', 'P', 'OP1'])
      )
    restype_rigid_group_mask[restype, 0] = True
    restype_rigid_group_depend[restype, 0] = torsion_angles_depend[restype][0]

    # pre-omega-frame to backbone (currently dummy identity matrix)
    restype_rigid_group_default_frame[restype, 1, :, :] = np.eye(4)

    # phi-frame to backbone
    if moltype(restype) == PROT:
      mat = _make_rigid_transformation_4x4(
          ex=atom_positions['N'] - atom_positions['CA'],
          ey=np.array([1., 0., 0.]),
          translation=atom_positions['N']
      )
      restype_rigid_group_default_frame[restype, 2, :, :] = mat
    restype_rigid_group_depend[restype, 2] = torsion_angles_depend[restype][1]

    # psi-frame to backbone
    if moltype(restype) == PROT and torsion_angles_mask[restype][2]:
      mat = _make_rigid_transformation_4x4(
          ex=atom_positions['C'] - atom_positions['CA'],
          ey=atom_positions['CA'] - atom_positions['N'],
          translation=atom_positions['C']
      )
      restype_rigid_group_atom14_idx[restype, 3, :] = np.array(
          to_atom14_index(resname, ['CA', 'C', 'O'])
      )
      restype_rigid_group_default_frame[restype, 3, :, :] = mat
      restype_rigid_group_mask[restype, 3] = True
      restype_rigid_group_depend[restype, 3] = torsion_angles_depend[restype][2]

    # chi_1(prot),alpha(na)-frame to backbone
    if torsion_angles_mask[restype][3]:
      base_atom_names = torsion_angles_atoms[resname][3]
      base_atom_positions = [atom_positions[name] for name in base_atom_names]
      mat = _make_rigid_transformation_4x4(
          ex=base_atom_positions[2] - base_atom_positions[1],
          ey=base_atom_positions[0] - base_atom_positions[1],
          translation=base_atom_positions[2]
      )
      restype_rigid_group_default_frame[restype, 4, :, :] = mat
      restype_rigid_group_atom14_idx[restype, 4, :] = np.array(
          to_atom14_index(resname, base_atom_names[1:])
      )
      restype_rigid_group_depend[restype, 4] = torsion_angles_depend[restype][3]

    # chi2-frame to chi1-frame
    # chi3-frame to chi2-frame
    # chi4-frame to chi3-frame
    # luckily all rotation axes for the next frame start at (0,0,0) of the
    # previous frame
    for chi_idx in range(4, chi_angles_num):  # pylint: disable=redefined-outer-name
      if torsion_angles_mask[restype][chi_idx]:
        axis_end_atom_name = torsion_angles_atoms[resname][chi_idx][2]
        axis_end_atom_position = atom_positions[axis_end_atom_name]
        mat = _make_rigid_transformation_4x4(
            ex=axis_end_atom_position,
            ey=np.array([-1., 0., 0.]),
            translation=axis_end_atom_position
        )
        restype_rigid_group_default_frame[restype, 1 + chi_idx, :, :] = mat
        restype_rigid_group_atom14_idx[restype, 1 + chi_idx, :] = np.array(
            to_atom14_index(resname, torsion_angles_atoms[resname][chi_idx][1:])
        )
        restype_rigid_group_mask[restype, 1 + chi_idx] = True
        restype_rigid_group_depend[
            restype, 1 + chi_idx
        ] = torsion_angles_depend[restype][chi_idx]


_make_rigid_group_constants()

atom14_van_der_waals_radius = np.zeros(
    (restype_num + 1, atom14_type_num), dtype=np.float32
)


def _make_atom14_van_der_waals_radius():
  for restype, restype_letter in enumerate(restypes):
    if not is_aa(restype):
      continue

    resname = restype_1to3[(restype_letter, moltype(restype))]
    atom_list = restype_name_to_atom14_names[resname]  # pylint: disable=redefined-outer-name
    for atom_idx, atom_name in enumerate(atom_list):  # pylint: disable=redefined-outer-name
      if not atom_name:
        continue
      atom_radius = van_der_waals_radius[atom_name[0]]
      atom14_van_der_waals_radius[restype, atom_idx] = atom_radius


_make_atom14_van_der_waals_radius()


def make_atom14_dists_bounds(overlap_tolerance=1.5, bond_length_tolerance_factor=15):
  """compute upper and lower bounds for bonds to assess violations."""
  restype_atom14_bond_lower_bound = np.zeros(
      [restype_num + 1, atom14_type_num, atom14_type_num], np.float32
  )
  restype_atom14_bond_upper_bound = np.zeros(
      [restype_num + 1, atom14_type_num, atom14_type_num], np.float32
  )
  restype_atom14_bond_stddev = np.zeros(
      [restype_num + 1, atom14_type_num, atom14_type_num], np.float32
  )
  residue_bonds, residue_virtual_bonds, _ = load_stereo_chemical_props()
  for restype, restype_letter in enumerate(restypes):
    if not is_aa(restype):
      continue

    resname = restype_1to3[(restype_letter, moltype(restype))]
    atom_list = restype_name_to_atom14_names[resname]  # pylint: disable=redefined-outer-name

    # create lower and upper bounds for clashes
    for atom1_idx, atom1_name in enumerate(atom_list):
      if not atom1_name:
        continue
      atom1_radius = van_der_waals_radius[atom1_name[0]]
      for atom2_idx, atom2_name in enumerate(atom_list):
        if (not atom2_name) or atom1_idx == atom2_idx:
          continue
        atom2_radius = van_der_waals_radius[atom2_name[0]]
        lower = atom1_radius + atom2_radius - overlap_tolerance
        upper = 1e10
        restype_atom14_bond_lower_bound[restype, atom1_idx, atom2_idx] = lower
        restype_atom14_bond_lower_bound[restype, atom2_idx, atom1_idx] = lower
        restype_atom14_bond_upper_bound[restype, atom1_idx, atom2_idx] = upper
        restype_atom14_bond_upper_bound[restype, atom2_idx, atom1_idx] = upper

    # overwrite lower and upper bounds for bonds and angles
    for b in residue_bonds[resname] + residue_virtual_bonds[resname]:
      atom1_idx = atom_list.index(b.atom1_name)
      atom2_idx = atom_list.index(b.atom2_name)
      lower = b.length - bond_length_tolerance_factor * b.stddev
      upper = b.length + bond_length_tolerance_factor * b.stddev
      restype_atom14_bond_lower_bound[restype, atom1_idx, atom2_idx] = lower
      restype_atom14_bond_lower_bound[restype, atom2_idx, atom1_idx] = lower
      restype_atom14_bond_upper_bound[restype, atom1_idx, atom2_idx] = upper
      restype_atom14_bond_upper_bound[restype, atom2_idx, atom1_idx] = upper
      restype_atom14_bond_stddev[restype, atom1_idx, atom2_idx] = b.stddev
      restype_atom14_bond_stddev[restype, atom2_idx, atom1_idx] = b.stddev
  return {
      'lower_bound': restype_atom14_bond_lower_bound,  # shape (21,14,14)
      'upper_bound': restype_atom14_bond_upper_bound,  # shape (21,14,14)
      'stddev': restype_atom14_bond_stddev,  # shape (21,14,14)
  }


def _make_renaming_matrices():
  """Matrices to map atoms to symmetry partners in ambiguous case."""
  # As the atom naming is ambiguous for 7 of the 20 amino acids, provide
  # alternative groundtruth coordinates where the naming is swapped
  # Matrices for renaming ambiguous atoms.
  all_matrices = {res: np.eye(atom14_type_num, dtype=np.float32) for res in resnames}
  for resname, swap in residue_atom_renaming_swaps.items():
    correspondences = np.arange(atom14_type_num)
    for source_atom_swap, target_atom_swap in swap.items():
      source_index = restype_name_to_atom14_names[resname].index(source_atom_swap)
      target_index = restype_name_to_atom14_names[resname].index(target_atom_swap)
      correspondences[source_index] = target_index
      correspondences[target_index] = source_index
    renaming_matrix = np.zeros((atom14_type_num, atom14_type_num), dtype=np.float32)
    for index, correspondence in enumerate(correspondences):
      renaming_matrix[index, correspondence] = 1.
    all_matrices[resname] = renaming_matrix.astype(np.float32)
  renaming_matrices = np.stack([all_matrices[restype] for restype in resnames])
  return renaming_matrices


RENAMING_MATRICES = _make_renaming_matrices()
